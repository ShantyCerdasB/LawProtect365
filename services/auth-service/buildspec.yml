version: 0.2

phases:
  install:
    runtime-versions:
      nodejs: 20

  pre_build:
    commands:
      - |
        set -eu
        echo "[INFO] ===== Pre-build ====="
      - echo "[INFO] Using compiled artifacts from Test stage (no npm ci / prisma generate here)"

  build:
    commands:
      - |
        set -eu
        echo "[INFO] ===== Build & Package ====="
      - echo "[INFO] Skipping service build; using dist from Test stage"

      # ===== Deps layer skipped (using bundled core) =====
      - |
        echo "[INFO] Skipping dependencies layer; core layer will include runtime deps via bundling"

      # ===== Shared-TS layer (SKIPPED here; managed by separate pipeline/layer) =====
      - |
        echo "[INFO] Skipping shared-ts layer build/publish in this pipeline (managed separately)"

      # ===== Prisma layer (SKIPPED; Prisma lives in shared-ts layer) =====
      - |
        echo "[INFO] Skipping prisma layer; @prisma/client y engines go in shared-ts layer"

      # ===== Core layer (resolve latest version; publication handled separately) =====
      - |
        echo "[INFO] Resolving core layer latest (no build/publish here)"
        CORE_LAYER_NAME="${AUTH_LAYER_NAME:-lawprotect365-auth-core-${ENV:-stg}}"
        CORE_LAYER_ARN="$(aws lambda list-layer-versions \
          --layer-name "$CORE_LAYER_NAME" \
          --query "sort_by(LayerVersions, &Version)[-1].LayerVersionArn" \
          --output text 2>/dev/null || true)"
        if [ -z "$CORE_LAYER_ARN" ] || [ "$CORE_LAYER_ARN" = "None" ] || [ "$CORE_LAYER_ARN" = "null" ]; then
          echo "[WARN] Core layer not found for $CORE_LAYER_NAME; proceeding without it"
        else
          echo "[INFO] Core layer ARN: $CORE_LAYER_ARN"
        fi

      # ===== Function ZIPs (minimal CJS wrappers) =====
      - |
        echo "[INFO] Creating minimal CJS function ZIPs"
        cd "$CODEBUILD_SRC_DIR/services/auth-service"

        make_zip() {
          local zip="$1"
          local exp="$2"
          rm -rf __tmp_fn
          mkdir -p __tmp_fn
          cat > __tmp_fn/index.js << EOF
        const { webcrypto } = require('node:crypto');
        if (!globalThis.crypto) { globalThis.crypto = webcrypto; }
        const core = require('@lawprotect/auth-core');
        const root = (core && (core.handlers || (core.default && core.default.handlers))) ? (core.handlers || core.default.handlers) : (core || {});
        const alias = {
          getMe: 'getMeHandler',
          patchMe: 'patchMeHandler',
          linkProvider: 'linkProviderHandler',
          unlinkProvider: 'unlinkProviderHandler',
          getUsersAdmin: 'getUsersAdminHandler',
          getUserByIdAdmin: 'getUserByIdAdminHandler',
          setUserRoleAdmin: 'setUserRoleAdminHandler',
          setUserStatusAdmin: 'setUserStatusAdminHandler',
          preAuthentication: 'preAuthenticationHandler',
          postAuthentication: 'postAuthenticationHandler',
          postConfirmation: 'postConfirmationHandler',
          preTokenGeneration: 'preTokenGenerationHandler'
        };
        // For triggers, they are instances, so we call handler() method
        let fn = root['${exp}'] || root[alias['${exp}']] || root['${exp}Handler'];
        // If it's a trigger instance, get the handler method
        if (fn && typeof fn.handler === 'function') {
          fn = fn.handler.bind(fn);
        }
        if (typeof fn !== 'function') {
          throw new Error('Handler ${exp} not found in @lawprotect/auth-core. Available: ' + Object.keys(root).join(', '));
        }
        exports.handler = fn;
        EOF
          cat > __tmp_fn/package.json << 'EOF'
        { "type": "commonjs" }
        EOF
          (cd __tmp_fn && zip -qr "../$zip" .)
          rm -rf __tmp_fn
        }

        make_zip "auth-get-me.zip"                "getMe"
        make_zip "auth-patch-me.zip"              "patchMe"
        make_zip "auth-link-provider.zip"         "linkProvider"
        make_zip "auth-unlink-provider.zip"       "unlinkProvider"
        make_zip "auth-get-users-admin.zip"       "getUsersAdmin"
        make_zip "auth-get-user-by-id-admin.zip"  "getUserByIdAdmin"
        make_zip "auth-set-user-role-admin.zip"   "setUserRoleAdmin"
        make_zip "auth-set-user-status-admin.zip" "setUserStatusAdmin"
        make_zip "auth-pre-authentication.zip"    "preAuthentication"
        make_zip "auth-post-authentication.zip"   "postAuthentication"
        make_zip "auth-post-confirmation.zip"     "postConfirmation"
        make_zip "auth-pre-token-generation.zip"  "preTokenGeneration"

      # ===== Resolve layers to latest version (no publish) =====
      - |
        echo "[INFO] Resolving layer versions (no publish in this stage)"
        set -eu
        cd "$CODEBUILD_SRC_DIR/services/auth-service"

        if [ -z "${CODE_BUCKET:-}" ]; then
          echo "[ERROR] CODE_BUCKET not set"
          exit 1
        fi

        AWS_REGION="${AWS_REGION:-${AWS_DEFAULT_REGION:-us-east-1}}"
        CORE_LAYER_NAME="${AUTH_LAYER_NAME:-lawprotect365-auth-core-${ENV:-stg}}"
        SHARED_LAYER_NAME="${SHARED_TS_LAYER_NAME:-${PROJECT_NAME:-lawprotect365}-shared-ts-layer-${ENV:-stg}}"

        # Always prefer the latest published version by name
        CORE_LAYER_ARN="$(aws lambda list-layer-versions \
          --region "$AWS_REGION" --layer-name "$CORE_LAYER_NAME" \
          --query "sort_by(LayerVersions, &Version)[-1].LayerVersionArn" \
          --output text 2>/dev/null || true)"
        SHARED_LAYER_ARN="$(aws lambda list-layer-versions \
          --region "$AWS_REGION" --layer-name "$SHARED_LAYER_NAME" \
          --query "sort_by(LayerVersions, &Version)[-1].LayerVersionArn" \
          --output text 2>/dev/null || true)"

        # Fallbacks if list-layer-versions fails
        if [ -z "$CORE_LAYER_ARN" ] || [ "$CORE_LAYER_ARN" = "None" ] || [ "$CORE_LAYER_ARN" = "null" ]; then
          CORE_LAYER_ARN="${AUTH_LAYER_ARN:-}"
        fi
        if [ -z "$SHARED_LAYER_ARN" ] || [ "$SHARED_LAYER_ARN" = "None" ] || [ "$SHARED_LAYER_ARN" = "null" ]; then
          SHARED_LAYER_ARN="${SHARED_TS_LAYER_ARN:-}"
        fi

        echo "[INFO] Core layer ARN:   ${CORE_LAYER_ARN:-<empty>}"
        echo "[INFO] Shared layer ARN: ${SHARED_LAYER_ARN:-<empty>}"

      # ===== Deploy functions =====
      - |
        echo "[INFO] Deploying Lambda functions (no alias shift; CodeDeploy will move aliases)"
        cd "$CODEBUILD_SRC_DIR/services/auth-service"

        AWS_ACCOUNT_ID="${AWS_ACCOUNT_ID:-$(aws sts get-caller-identity --query Account --output text)}"

        build_layers_args() {
          args=""
          if [ -n "${SHARED_LAYER_ARN:-}" ] && [ "${SHARED_LAYER_ARN}" != "None" ]; then
            args="${args} ${SHARED_LAYER_ARN}"
          fi
          if [ -n "${CORE_LAYER_ARN:-}" ] && [ "${CORE_LAYER_ARN}" != "None" ]; then
            args="${args} ${CORE_LAYER_ARN}"
          fi
          echo "$args" | sed -e 's/^ *//'
        }

        # Build manifest JSON to iterate
        python3 - "$FUNCTIONS_MANIFEST" > /tmp/functions.json << 'PY'
        import json,sys
        raw = sys.argv[1] if len(sys.argv)>1 else "[]"
        try:
          data = json.loads(raw)
          assert isinstance(data, list)
        except Exception:
          data = []
        print(json.dumps(data))
        PY
        jq -e . >/dev/null 2>&1 || { echo "[ERROR] jq is required"; exit 1; }
        FUNS="$(cat /tmp/functions.json)"
        LAYERS_ARGS="$(build_layers_args)"
        : > /tmp/versions.jsonl

        retry() {
          local attempts="$1"; shift
          local delay=2
          local i
          for i in $(seq 1 "$attempts"); do
            if "$@"; then return 0; fi
            local rc=$?
            echo "[WARN] Retry $i failed (rc=$rc). Sleeping ${delay}s..." >&2
            sleep "$delay"
            delay=$((delay*2))
          done
          return 1
        }

        for row in $(echo "$FUNS" | jq -c '.[]'); do
          FN=$(echo "$row" | jq -r '.functionName')
          ZIP=$(echo "$row" | jq -r '.artifactS3Key')
          ALIAS=$(echo "$row" | jq -r '.alias')
          echo "[INFO] Deploying $FN (artifact=$ZIP, alias=$ALIAS)"
          aws s3 cp "$ZIP" "s3://$CODE_BUCKET/$ZIP"
          retry 5 aws lambda update-function-code --function-name "$FN" --s3-bucket "$CODE_BUCKET" --s3-key "$ZIP" >/dev/null
          aws lambda wait function-updated --function-name "$FN"
          ENV_JSON="$(aws lambda get-function-configuration --function-name "$FN" --query 'Environment.Variables' --output json 2>/dev/null || echo '{}')"
          ENV_ARG="$(python3 -c "import json,sys; raw=sys.argv[1] if len(sys.argv)>1 else '{}'; env=json.loads(raw or '{}') or {}; env['NODE_OPTIONS']='--experimental-specifier-resolution=node'; print(json.dumps({'Variables': env}, separators=(',',':')))" "$ENV_JSON")"
          if [ -n "$LAYERS_ARGS" ]; then
            retry 5 aws lambda update-function-configuration --function-name "$FN" --runtime nodejs20.x --handler index.handler --layers $LAYERS_ARGS --environment "$ENV_ARG" >/dev/null
          else
            retry 5 aws lambda update-function-configuration --function-name "$FN" --runtime nodejs20.x --handler index.handler --environment "$ENV_ARG" >/dev/null
          fi
          aws lambda wait function-updated --function-name "$FN"
          CURRENT_BEFORE="$(aws lambda get-alias --function-name "$FN" --name "$ALIAS" --query FunctionVersion --output text 2>/dev/null || true)"
          TARGET_VERSION="$(aws lambda publish-version --function-name "$FN" --description "Build-$(date +%s)" --query Version --output text 2>/dev/null || true)"
          if [ -z "$TARGET_VERSION" ] || [ "$TARGET_VERSION" = "None" ] || [ "$TARGET_VERSION" = "null" ]; then
            # Fallback: latest numeric published version
            TARGET_VERSION="$(aws lambda list-versions-by-function --function-name "$FN" \
              --query "sort_by(Versions[?Version!='\\\$LATEST'], &Version)[-1].Version" \
              --output text 2>/dev/null || true)"
          fi
          [ -z "$TARGET_VERSION" ] && TARGET_VERSION="$CURRENT_BEFORE"
          [ -z "$TARGET_VERSION" ] && TARGET_VERSION="1"
          if [ -z "$CURRENT_BEFORE" ] || [ "$CURRENT_BEFORE" = "None" ] || [ "$CURRENT_BEFORE" = "$LATEST" ] || [ "$CURRENT_BEFORE" = "\$LATEST" ]; then
            CURRENT_BEFORE="$(aws lambda list-versions-by-function --function-name "$FN" \
              --query "sort_by(Versions[?Version!='\\\$LATEST'], &Version)[-1].Version" \
              --output text 2>/dev/null || true)"
          fi
          [ -z "$CURRENT_BEFORE" ] && CURRENT_BEFORE="1"
          echo "{\"name\":\"$FN\",\"alias\":\"$ALIAS\",\"current\":\"$CURRENT_BEFORE\",\"target\":\"$TARGET_VERSION\"}" >> /tmp/versions.jsonl

          # Sanity invoke the published version to surface runtime errors without failing the build
          ERR=$(aws lambda invoke --function-name "$FN" --qualifier "$TARGET_VERSION" --payload '{}' /tmp/invoke.json --query FunctionError --output text 2>/dev/null || true)
          if [ -n "$ERR" ] && [ "$ERR" != "None" ]; then
            echo "[WARN] Sanity invoke failed for $FN (v$TARGET_VERSION) FunctionError=$ERR"
            cat /tmp/invoke.json || true
          else
            echo "[INFO] Sanity invoke OK for $FN (v$TARGET_VERSION)"
          fi
        done

      - |
        echo "[INFO] Writing per-function appspec.yml files for CodeDeploy"
        OUTROOT="$CODEBUILD_SRC_DIR/services/auth-service/out/appspecs"
        while read -r line; do
          NAME="$(echo "$line" | jq -r '.name')"
          ALIAS="$(echo "$line" | jq -r '.alias')"
          CURR="$(echo "$line" | jq -r '.current')"
          TGT="$(echo "$line" | jq -r '.target')"
          ARTID="$(echo "$FUNS" | jq -r --arg fn "$NAME" '.[] | select(.functionName==$fn) | .artifactIdentifier')"
          OUTDIR="$OUTROOT/${ARTID}"
          mkdir -p "$OUTDIR" || true
          {
            echo "version: 0.0"
            echo "Resources:"
            echo "  - $(basename "$NAME"):"
            echo "      Type: AWS::Lambda::Function"
            echo "      Properties:"
            echo "        Name: \"$NAME\""
            echo "        Alias: \"$ALIAS\""
            echo "        CurrentVersion: $CURR"
            echo "        TargetVersion: $TGT"
          } > "$OUTDIR/appspec.yml"
        done < /tmp/versions.jsonl

artifacts:
  files: []
  discard-paths: yes
  secondary-artifacts:
    auth_get-me_artifact:
      base-directory: services/auth-service/out/appspecs/auth_get-me_artifact
      files:
        - appspec.yml
      discard-paths: yes
    auth_patch-me_artifact:
      base-directory: services/auth-service/out/appspecs/auth_patch-me_artifact
      files:
        - appspec.yml
      discard-paths: yes
    auth_link-provider_artifact:
      base-directory: services/auth-service/out/appspecs/auth_link-provider_artifact
      files:
        - appspec.yml
      discard-paths: yes
    auth_unlink-provider_artifact:
      base-directory: services/auth-service/out/appspecs/auth_unlink-provider_artifact
      files:
        - appspec.yml
      discard-paths: yes
    auth_get-users-admin_artifact:
      base-directory: services/auth-service/out/appspecs/auth_get-users-admin_artifact
      files:
        - appspec.yml
      discard-paths: yes
    auth_get-user-by-id-admin_artifact:
      base-directory: services/auth-service/out/appspecs/auth_get-user-by-id-admin_artifact
      files:
        - appspec.yml
      discard-paths: yes
    auth_set-user-role-admin_artifact:
      base-directory: services/auth-service/out/appspecs/auth_set-user-role-admin_artifact
      files:
        - appspec.yml
      discard-paths: yes
    auth_set-user-status-admin_artifact:
      base-directory: services/auth-service/out/appspecs/auth_set-user-status-admin_artifact
      files:
        - appspec.yml
      discard-paths: yes
    auth_pre-authentication_artifact:
      base-directory: services/auth-service/out/appspecs/auth_pre-authentication_artifact
      files:
        - appspec.yml
      discard-paths: yes
    auth_post-authentication_artifact:
      base-directory: services/auth-service/out/appspecs/auth_post-authentication_artifact
      files:
        - appspec.yml
      discard-paths: yes
    auth_post-confirmation_artifact:
      base-directory: services/auth-service/out/appspecs/auth_post-confirmation_artifact
      files:
        - appspec.yml
      discard-paths: yes
    auth_pre-token-generation_artifact:
      base-directory: services/auth-service/out/appspecs/auth_pre-token-generation_artifact
      files:
        - appspec.yml
      discard-paths: yes

