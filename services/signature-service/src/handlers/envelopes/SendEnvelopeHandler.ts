/**
 * @fileoverview SendEnvelopeHandler - Handler for sending envelopes to signers
 * @summary Handles envelope sending with invitation generation and notification dispatch
 * @description This handler processes requests to send envelopes to signers,
 * including invitation token generation, notification dispatch, and status updates.
 * It supports sending to all signers or specific signers with custom messages.
 */

import { ControllerFactory, VALID_COGNITO_ROLES } from '@lawprotect/shared-ts';
import { ServiceFactory } from '../../infrastructure/factories/ServiceFactory';
import { SendEnvelopePathSchema, SendEnvelopeBodySchema } from '../../domain/schemas/SendEnvelopeSchema';
import { EnvelopeId } from '../../domain/value-objects/EnvelopeId';

/**
 * SendEnvelopeHandler - Production-ready handler using ControllerFactory
 *
 * @description This handler orchestrates envelope sending with invitation token generation
 * and notification dispatch. It supports flexible sending options including custom messages
 * and selective signer targeting.
 *
 * @middleware
 * - JWT Authentication: Validates user identity and token validity
 * - Role validation: Ensures user has appropriate role permissions
 * - Request validation: Validates request body using SendEnvelopeSchema
 * - Service orchestration: Coordinates between domain services using SignatureOrchestrator
 * - Response formatting: Transforms domain entities to API response format
 *
 * @flow
 * 1. Validation - Validates request body and business rules
 * 2. Envelope Sending - Sends envelope using SignatureOrchestrator
 * 3. Token Generation - Generates invitation tokens for target signers
 * 4. Notification Dispatch - Publishes events for notification service
 * 5. Response Assembly - Returns confirmation with details
 *
 * @responsibilities
 * - Envelope Sending: Validates and sends envelope to signers
 * - Token Management: Generates invitation tokens for external signers
 * - Notification Coordination: Publishes events for notification service
 * - Response Formatting: Transforms domain entities to API response format
 *
 * @exclusions
 * - Email Notifications: Handled by NotificationService via events
 * - Document Storage: Handled by Document Service
 * - Document Processing: Handled by Document Service
 * - Audit Events: Generated by individual services
 * - Permission Validation: Handled by middleware pipeline
 *
 * @sendingOptions
 * - sendToAll: Send to all external signers with same message
 * - signers: Send to specific signers with custom messages
 * - message: General message for all signers
 * - signers[].message: Custom message per signer
 */
export const sendEnvelopeHandler = ControllerFactory.createCommand({
  // Validation schemas
  pathSchema: SendEnvelopePathSchema,
  bodySchema: SendEnvelopeBodySchema,
  
  // Service configuration - use new DDD architecture
  appServiceClass: class {
    private readonly signatureOrchestrator: any;

    constructor() {
      this.signatureOrchestrator = ServiceFactory.createSignatureOrchestrator();
    }

    /**
     * Executes the envelope sending orchestration
     * 
     * @param params - Extracted parameters from request
     * @returns Promise resolving to send envelope result
     */
    async execute(params: any) {
      const result = await this.signatureOrchestrator.sendEnvelope(
        params.envelopeId,
        params.userId,
        params.securityContext,
        {
          message: params.message,
          sendToAll: params.sendToAll,
          signers: params.signers
        }
      );

      return result;
    }
  },
  
  extractParams: (path: any, body: any, _query: any, context: any) => ({
    envelopeId: EnvelopeId.fromString(path.envelopeId),
    message: body.message,
    sendToAll: body.sendToAll || false,
    signers: body.signers,
    userId: context.auth.userId,
    securityContext: {
      ipAddress: context.auth.ipAddress,
      userAgent: context.auth.userAgent,
      country: context.auth.country
    }
  }),
  
  responseType: 'ok',
  transformResult: async (result: any) => {
    return {
      success: result.success,
      message: result.message,
      envelopeId: result.envelopeId,
      status: result.status,
      tokensGenerated: result.tokensGenerated,
      signersNotified: result.signersNotified
    };
  },
  
  requireAuth: true,
  requiredRoles: [...VALID_COGNITO_ROLES],
  includeSecurityContext: true
});