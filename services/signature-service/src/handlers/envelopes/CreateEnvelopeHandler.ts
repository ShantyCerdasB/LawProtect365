/**
 * @fileoverview CreateEnvelopeHandler - Handler for creating new envelopes with signers
 * @summary Handles envelope creation orchestration with signers (without invitation tokens)
 * @description This handler orchestrates the creation of a new envelope with all signers included.
 * It uses the new DDD architecture with Prisma repositories and validates business rules.
 * Invitation tokens are generated separately in the Send Invitations flow.
 */

import { ControllerFactory, VALID_COGNITO_ROLES } from '@lawprotect/shared-ts';
import { CreateEnvelopeSchema } from '../../domain/schemas/EnvelopeSchema';
import { CompositionRoot } from '../../infrastructure/factories';
import { DocumentOrigin } from '../../domain/value-objects/DocumentOrigin';
import { SigningOrder } from '../../domain/value-objects/SigningOrder';


/**
 * CreateEnvelopeHandler - Production-ready handler using ControllerFactory
 *
 * @description This handler orchestrates envelope creation with signers using the new DDD architecture.
 * It uses SignatureOrchestrator to coordinate between SignatureEnvelopeService and EnvelopeSignerService.
 * Invitation tokens are generated separately in the Send Invitations flow.
 *
 * @middleware
 * - JWT Authentication: Validates user identity and token validity
 * - Role validation: Ensures user has appropriate role permissions
 * - Request validation: Validates request body using CreateEnvelopeSchema
 * - Service orchestration: Coordinates between domain services using SignatureOrchestrator
 * - Response formatting: Transforms domain entities to API response format
 *
 * @flow
 * 1. Validation - Validates request body and business rules
 * 2. Envelope Creation - Creates envelope using SignatureOrchestrator
 * 3. Signer Creation - Creates signers with proper order assignment
 * 4. Response Assembly - Returns complete envelope with signers
 *
 * @responsibilities
 * - Envelope Creation: Creates envelope with metadata and business rules validation
 * - Signer Management: Creates all signers with proper order assignment
 * - Business Validation: Validates business rules and constraints
 * - Response Formatting: Transforms domain entities to API response format
 *
 * @exclusions
 * - Invitation Token Generation: Handled separately in Send Invitations flow
 * - Email Notifications: Handled by NotificationService
 * - Document Storage: Handled by Document Service
 * - Document Processing: Handled by Document Service
 * - Audit Events: Generated by individual services
 * - Permission Validation: Handled by middleware pipeline
 *
 * @signingOrder
 * - OWNER_FIRST: Owner signs first (order 1), then all invited signers (no specific order)
 * - INVITEES_FIRST: All invited signers sign first (no specific order), then owner signs last
 * - Signers are created with proper order assignment based on signing order type
 */
export const createEnvelopeHandler = ControllerFactory.createCommand({
  // Validation schemas
  bodySchema: CreateEnvelopeSchema,
  
  // Service configuration - use new DDD architecture
  /**
   * Lazy DI: delay orchestrator creation until first call to avoid import-time
   * DB requirements. Supports resolving DATABASE_URL via shared-ts at runtime.
   */
  appServiceClass: class {
    private signatureOrchestrator: any | undefined;

    /**
     * Executes the envelope creation orchestration
     * @param params - Extracted parameters from request
     * @returns Promise resolving to created envelope
     */
    async execute(params: any) {
      const orchestrator = this.signatureOrchestrator ?? await CompositionRoot.createSignatureOrchestratorAsync();
      this.signatureOrchestrator = orchestrator;
      const result = await orchestrator.createEnvelope({
        envelopeData: params.envelopeData,
        userId: params.userId,
        securityContext: params.securityContext,
        actorEmail: params.actorEmail
      });

      return {
        envelope: result.envelope
      };
    }
  },
  
  // Parameter extraction - transforms HTTP request to domain parameters
  extractParams: (_path: any, body: any, _query: any, context: any) => ({
    envelopeData: {
      createdBy: context.auth.userId, // Authenticated user ID
      title: body.title,
      description: body.description,
      origin: DocumentOrigin.fromString(body.originType, body.templateId, body.templateVersion),
      signingOrder: SigningOrder.fromString(body.signingOrderType || 'OWNER_FIRST'),
      expiresAt: body.expiresAt,
      sourceKey: body.sourceKey,
      metaKey: body.metaKey
    },
    userId: context.auth.userId,
    securityContext: context.auth,
    actorEmail: context.auth.email
  }),
  
  // Response configuration
  responseType: 'created',
  transformResult: async (result: any) => {
    return {
      id: result.envelope.getId().getValue(),
      title: result.envelope.getTitle(),
      description: result.envelope.getDescription(),
      status: result.envelope.getStatus().getValue(),
      signingOrderType: result.envelope.getSigningOrder().getType(),
      originType: result.envelope.getOrigin().getType(),
      createdBy: result.envelope.getCreatedBy(),
      sourceKey: result.envelope.getSourceKey()?.getValue(),
      metaKey: result.envelope.getMetaKey()?.getValue(),
      expiresAt: result.envelope.getExpiresAt(),
      createdAt: result.envelope.getCreatedAt(),
      ...(result.envelope.getOrigin().getType() === 'TEMPLATE' && {
        templateId: result.envelope.getOrigin().getTemplateId(),
        templateVersion: result.envelope.getOrigin().getTemplateVersion()
      })
    };
  },
  
  requireAuth: true,
  requiredRoles: [...VALID_COGNITO_ROLES],
  includeSecurityContext: true
});