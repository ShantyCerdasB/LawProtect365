/**
 * @fileoverview ViewDocumentHandler - Handler for document viewing
 * @summary Handles document viewing with invitation token validation
 * @description This handler provides secure access to documents for external signers
 * using invitation tokens without requiring authentication.
 */

import { ControllerFactory } from '@lawprotect/shared-ts';
import { InvitationTokenPathSchema } from '../../domain/schemas/SigningHandlersSchema';
import { ServiceFactory } from '../../infrastructure/factories/ServiceFactory';
import { InvitationTokenService } from '../../services/InvitationTokenService';
import { S3Service } from '../../services/S3Service';
import { SignerService } from '../../services/SignerService';
import { EnvelopeService } from '../../services/EnvelopeService';
import { InvitationToken } from '../../domain/entities/InvitationToken';
import { SignerId } from '../../domain/value-objects/SignerId';
import { EnvelopeId } from '../../domain/value-objects/EnvelopeId';
import { loadConfig } from '../../config';

/**
 * ViewDocumentHandler - Production-ready handler using ControllerFactory
 * 
 * This handler provides secure access to documents for external signers using
 * invitation tokens. It uses ControllerFactory with a comprehensive middleware
 * pipeline.
 * 
 * @middleware
 * - Request validation: Validates invitation token format
 * - Token validation: Validates token exists and is not expired
 * - Service orchestration: Coordinates between domain services
 * - Response formatting: Transforms domain entities to API response format
 * 
 * @flow
 * 1. Token Validation - Validates invitation token from path parameters
 * 2. Document Access - Retrieves document information from S3Service
 * 3. URL Generation - Generates presigned URL for secure document access
 * 4. Response Assembly - Returns complete document access information
 * 
 * @responsibilities
 * - Token Validation: Validates invitation tokens for document access
 * - Document Access: Provides secure access to documents via presigned URLs
 * - URL Generation: Generates time-limited presigned URLs
 * - Response Formatting: Transforms domain entities to API response format
 * 
 * @exclusions
 * - Document Storage: Handled by S3Service
 * - Token Management: Handled by InvitationTokenService
 * - Audit Events: Generated by individual services
 */
export const viewDocumentHandler = ControllerFactory.createCommand({
  // Validation schemas
  pathSchema: InvitationTokenPathSchema,
  
  // Parameter extraction
  extractParams: (path: any, _body: any, _query: any, context: any) => ({
    invitationToken: path.invitationToken,
    securityContext: context.securityContext
  }),
  
  // Service configuration - use domain services directly
  appServiceClass: class {
    constructor() {
      this.invitationTokenService = ServiceFactory.createInvitationTokenService();
      this.s3Service = ServiceFactory.createS3Service();
      this.signerService = ServiceFactory.createSignerService();
      this.envelopeService = ServiceFactory.createEnvelopeService();
      this.config = loadConfig();
    }
    
    private invitationTokenService: InvitationTokenService;
    private s3Service: S3Service;
    private signerService: SignerService;
    private envelopeService: EnvelopeService;
    private config: any;
    
    async execute(params: { invitationToken: string; securityContext: any }) {
      const { invitationToken, securityContext } = params;
      
      // Validate invitation token using service (validation handled by service)
      const tokenValidation: InvitationToken = await this.invitationTokenService.validateInvitationToken(invitationToken);
      
      // Get document information from S3Service
      const documentInfo = await this.s3Service.getDocumentInfo(tokenValidation.getEnvelopeId().getValue());
      
      // Generate presigned URL for document viewing with configurable TTL
      const presignedUrl = await this.s3Service.generatePresignedUrl({
        envelopeId: tokenValidation.getEnvelopeId(),
        signerId: tokenValidation.getSignerId(),
        documentKey: tokenValidation.getEnvelopeId().getValue(),
        operation: 'get',
        expiresIn: this.config.s3.documentViewTtlSeconds
      });
      
      // Security context is provided by shared-ts; no manual extraction needed

      // Log document view activity with real IP
      await this.invitationTokenService.markTokenAsUsed(invitationToken, 'external-user');
      
      // Get signer information from SignerService
      const signer = await this.signerService.getSigner(new SignerId(tokenValidation.getSignerId().getValue()));

      // Get envelope information from EnvelopeService
      const envelope = await this.envelopeService.getEnvelope(
        new EnvelopeId(tokenValidation.getEnvelopeId().getValue()),
        'external-user',
        securityContext
      );
      
      // Get signer information from token metadata as fallback
      const signerMetadata = tokenValidation.getMetadata();
      
      // Return document access information with real data
      return {
        document: {
          id: tokenValidation.getEnvelopeId().getValue(),
          envelopeId: tokenValidation.getEnvelopeId().getValue(),
          signerId: tokenValidation.getSignerId().getValue(),
          viewUrl: presignedUrl,
          expiresAt: new Date(Date.now() + this.config.s3.documentViewTtlSeconds * 1000).toISOString(),
          filename: documentInfo.filename,
          contentType: documentInfo.contentType,
          size: documentInfo.size
        },
        signer: {
          id: tokenValidation.getSignerId().getValue(),
          email: signer?.getEmail().getValue() || signerMetadata.email || 'unknown',
          fullName: signer?.getFullName() || signerMetadata.fullName || 'unknown',
          status: signer?.getStatus() || 'PENDING'
        },
        envelope: {
          id: tokenValidation.getEnvelopeId().getValue(),
          title: envelope.getMetadata().title || 'Document',
          status: envelope.getStatus(),
          signingOrder: envelope.getSigningOrder().getType()
        }
      };
    }
  },
  
  // Response configuration
  responseType: 'ok'
});