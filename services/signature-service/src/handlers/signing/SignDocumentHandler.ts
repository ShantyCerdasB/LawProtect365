/**
 * @fileoverview SignDocumentHandler - Handler for document signing
 * @summary Handles document signing with consent and signature creation
 * @description This handler processes document signing including consent validation,
 * signature creation, and status updates for both envelope and signer. It supports
 * both authenticated users (with JWT tokens) and external users (with invitation tokens).
 */

import { ControllerFactory, PermissionLevel, AccessType } from '@lawprotect/shared-ts';
import { SignDocumentRequestSchema } from '../../domain/schemas/SigningHandlersSchema';
// ServiceFactory is already imported above
import { SignatureService } from '../../services/SignatureService';
import { InvitationTokenService } from '../../services/InvitationTokenService';
import { EnvelopeService } from '../../services/EnvelopeService';
import { SignerService } from '../../services/SignerService';
import { InvitationToken } from '../../domain/entities/InvitationToken';
import { Signature } from '../../domain/entities/Signature';
import { Envelope } from '../../domain/entities/Envelope';
import { SignatureId } from '../../domain/value-objects/SignatureId';
import { EnvelopeId } from '../../domain/value-objects/EnvelopeId';
import { SignerId } from '../../domain/value-objects/SignerId';
import { SignatureStatus } from '../../domain/enums/SignatureStatus';
import { calculateEnvelopeProgress } from '../../utils/envelope-progress';
import { SignerStatus } from '../../domain/enums/SignerStatus';
import { ServiceFactory } from '../../infrastructure/factories/ServiceFactory';
import { ConsentService } from '../../services/ConsentService';
import { EnvelopeRepository } from '../../repositories/EnvelopeRepository';

/**
 * SignDocumentHandler - Production-ready handler using ControllerFactory
 * 
 * This handler processes document signing including consent validation,
 * signature creation, and status updates. It supports both authenticated
 * users (with JWT tokens) and external users (with invitation tokens).
 * 
 * @middleware
 * - JWT Authentication: Validates user identity and token validity (for authenticated users)
 * - Role validation: Ensures user has appropriate role permissions (for authenticated users)
 * - Request validation: Validates request body using SignDocumentRequestSchema
 * - Service orchestration: Coordinates between domain services
 * - Response formatting: Transforms domain entities to API response format
 * 
 * @flow
 * 1. Request Validation - Validates request body and determines user type
 * 2. User Authentication - Validates JWT token or invitation token
 * 3. Consent Validation - Validates consent for invitation token users
 * 4. Signature Creation - Creates signature using SignatureService
 * 5. Response Assembly - Returns complete signature information
 * 
 * @responsibilities
 * - Dual Authentication: Supports both JWT and invitation token authentication
 * - Signature Creation: Creates digital signatures using existing services
 * - Consent Validation: Validates consent for external users
 * - Business Validation: Validates business rules and constraints
 * - Response Formatting: Transforms domain entities to API response format
 * 
 * @exclusions
 * - Document Storage: Handled by S3Service (frontend uploads signed PDF)
 * - KMS Operations: Handled by SignatureService
 * - Audit Events: Generated by individual services
 * - Email Notifications: Handled by NotificationService
 */
export const signDocumentHandler = ControllerFactory.createCommand({
  // Validation schemas
  bodySchema: SignDocumentRequestSchema,
  
  // Parameter extraction
  extractParams: (_path: any, body: any, _query: any, context: any) => ({
    requestBody: body,
    securityContext: context.securityContext,
    actorEmail: context.auth?.email
  }),
  
  // Service configuration - use domain services directly
  appServiceClass: class {
    constructor() {
      // Create services from ServiceFactory
      this.signatureService = ServiceFactory.createSignatureService();
      this.invitationTokenService = ServiceFactory.createInvitationTokenService();
      this.envelopeService = ServiceFactory.createEnvelopeService();
      this.signerService = ServiceFactory.createSignerService();
      this.consentService = ServiceFactory.createConsentService();
    }
    
    private readonly signatureService: SignatureService;
    private readonly invitationTokenService: InvitationTokenService;
    private readonly envelopeService: EnvelopeService;
    private readonly signerService: SignerService;
    private readonly consentService: ConsentService;
    
    async execute(params: { requestBody: any; securityContext: any; actorEmail?: string }) {
      const { requestBody, securityContext } = params;
      let envelopeId: string;
      let signerId: string;
      let invitationToken: InvitationToken | null = null;
      let userEmail: string | undefined;
      
      // Determine authentication method and extract envelope/signer info
      if (requestBody.invitationToken) {
        // External user with invitation token - validation handled by service
        invitationToken = await this.invitationTokenService.validateInvitationToken(requestBody.invitationToken);
        envelopeId = invitationToken.getEnvelopeId().getValue();
        signerId = invitationToken.getSignerId().getValue();
        userEmail = invitationToken.getMetadata()?.email
      } else {
        // Authenticated user with JWT token
        envelopeId = requestBody.envelopeId;
        signerId = requestBody.signerId;
        // Resolve signer email from repository to ensure consent auth matches signer identity
        const signerEntity = await this.signerService.getSigner(new SignerId(signerId));
        userEmail = signerEntity?.getEmail().getValue();
      }

      // For external users, ensure we have a valid email for consent creation
      if (!userEmail && invitationToken) {
        userEmail = invitationToken.getMetadata()?.email || 'external-user@example.com';
      }

      // For external users (invitation token), authorize via sentinel userId
      const consentUserId = invitationToken ? 'external-user' : (securityContext?.userId || 'external-user');
      // Validate signing order BEFORE creating signature
      const userId = securityContext?.userId || 'external-user';
      const mergedSecurityContext = {
        ...(securityContext || {}),
        userId,
        permission: securityContext?.permission ?? PermissionLevel.PARTICIPANT,
        accessType: securityContext?.accessType ?? AccessType.INVITATION
      } as any;

      // Validate signing order without requiring envelope access
      console.log('[SignDocumentHandler] About to validate signing order:', { envelopeId, signerId, userId });
      await this.signerService.validateSigningOrder(
        new EnvelopeId(envelopeId),
        new SignerId(signerId),
        this.envelopeService,
        userId,
        mergedSecurityContext
      );
      console.log('[SignDocumentHandler] Signing order validation passed');

      // Create or ensure consent exists (mandatory for all flows)
      const consentPayload = requestBody.consent;
      if (!consentPayload || consentPayload.given !== true) {
        throw new Error('Consent is required and must be given');
      }
      const effectiveIp = consentPayload.ipAddress || securityContext?.ipAddress;
      const effectiveUa = consentPayload.userAgent || securityContext?.userAgent;

      const signatureId = new SignatureId(crypto.randomUUID());

      console.log('[SignDocumentHandler] About to create consent:', { envelopeId, signerId, userEmail, consentUserId });
      try {
        await this.consentService.createConsent({
          envelopeId: new EnvelopeId(envelopeId),
          signerId: new SignerId(signerId),
          signatureId,
          consentGiven: true,
          consentTimestamp: new Date(consentPayload.timestamp),
          consentText: consentPayload.text,
          ipAddress: effectiveIp,
          userAgent: effectiveUa,
          userEmail,
          country: securityContext?.country
        }, consentUserId || '');
        console.log('[SignDocumentHandler] Consent created successfully');
      } catch (e: any) {
        // Ignore conflict if consent already exists
        if (String(e?.code) !== 'COMMON_CONFLICT') {
          console.log('[SignDocumentHandler] Consent creation failed:', e);
          throw e;
        }
        console.log('[SignDocumentHandler] Consent already exists, continuing');
      }

      // Create signature using real SignatureService
      const signature: Signature = await this.signatureService.createSignature({
        id: signatureId,
        envelopeId: new EnvelopeId(envelopeId),
        signerId: new SignerId(signerId),
        documentHash: requestBody.documentHash,
        signatureHash: requestBody.signatureHash,
        s3Key: requestBody.s3Key,
        kmsKeyId: requestBody.kmsKeyId,
        algorithm: requestBody.algorithm,
        timestamp: new Date(),
        status: SignatureStatus.SIGNED,
        reason: requestBody.reason,
        location: requestBody.location,
        ipAddress: effectiveIp,
        userAgent: effectiveUa,
        userEmail,
        signerEmail: userEmail,
        signerFullName: invitationToken ? (await this.signerService.getSigner(new SignerId(signerId)))?.getFullName?.() : 'Owner',
        ownerUserId: securityContext?.userId,
        country: securityContext?.country
      });

      // Mark signer as signed using the service (handles event publishing logic)
      console.log('[SignDocumentHandler] About to mark signer as signed:', { signerId, userId: mergedSecurityContext.userId });
      await this.signerService.markSignerAsSigned(new SignerId(signerId), {
        userId: mergedSecurityContext.userId,
        ipAddress: securityContext?.ipAddress,
        userAgent: securityContext?.userAgent
      });
      console.log('[SignDocumentHandler] Signer marked as signed successfully');

      const allSigners = await this.signerService.getSignersByEnvelope(new EnvelopeId(envelopeId));
      const allSigned = allSigners.length > 0 && allSigners.every(s => s.getStatus() === SignerStatus.SIGNED);
      if (allSigned) {
        // Persist signed document key into envelope metadata for stable retrieval
        try {
          const envelopeRepo = new EnvelopeRepository((ServiceFactory as any).config.ddb.envelopesTable, (ServiceFactory as any).ddbClient, {
            indexName: (ServiceFactory as any).config.ddb.envelopesGsi1Name,
            gsi2IndexName: (ServiceFactory as any).config.ddb.envelopesGsi2Name
          });
          const currentEnv = await envelopeRepo.getById(new EnvelopeId(envelopeId));
          const currentMeta = (currentEnv as any)?.getMetadata?.() || {};
          await envelopeRepo.update(new EnvelopeId(envelopeId), {
            metadata: {
              ...currentMeta,
              signedS3Key: requestBody.s3Key
            }
          } as any);
        } catch (_e) {
          // best-effort; do not block signing flow
        }
        const ownerId = (allSigners.find(s => s.getOrder() === 1) as any)?.getOwnerId?.() || mergedSecurityContext.userId;
        const ownerContext = {
          ...mergedSecurityContext,
          userId: ownerId,
          permission: PermissionLevel.OWNER,
          accessType: AccessType.DIRECT
        } as any;
        await this.envelopeService.completeIfAllSigned(new EnvelopeId(envelopeId), ownerId, ownerContext as any);
      }

      // Get envelope status and progress
      let envelope: Envelope;
      try {
        envelope = await this.envelopeService.getEnvelope(new EnvelopeId(envelopeId), userId, mergedSecurityContext);
      } catch (_e) {
        // If we can't get envelope, create a minimal response
        envelope = {
          getStatus: () => 'SENT',
          getSigningOrder: () => ({ getType: () => 'OWNER_FIRST' })
        } as any;
      }
      
      // Get signers to calculate real progress
      const signers = await this.signerService.getSignersByEnvelope(new EnvelopeId(envelopeId));
      const progress = calculateEnvelopeProgress(signers);
      
      // Return signing confirmation with real data
    return {
        message: 'Document signed successfully',
        signature: {
          id: signature.getId().getValue(),
          signerId: signature.getSignerId(),
          envelopeId: signature.getEnvelopeId(),
          signedAt: signature.getTimestamp().toISOString(),
          algorithm: signature.getAlgorithm(),
          hash: signature.getSignatureHash()
        },
        envelope: {
          id: envelopeId,
          status: envelope.getStatus(),
          progress: progress.percentage
        }
      };
    }
  },
  
  // Response configuration
  responseType: 'ok'
});