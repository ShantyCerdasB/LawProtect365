/**
 * @fileoverview SignDocumentHandler - Handler for document signing
 * @summary Handles document signing with consent and signature creation
 * @description This handler processes document signing including consent validation,
 * signature creation, and status updates for both envelope and signer. It supports
 * both authenticated users (with JWT tokens) and external users (with invitation tokens).
 */

import { ControllerFactory } from '@lawprotect/shared-ts';
import { SignDocumentRequestSchema } from '../../domain/schemas/SigningHandlersSchema';
import { ServiceFactory } from '../../infrastructure/factories/ServiceFactory';
import { SignatureService } from '../../services/SignatureService';
import { InvitationTokenService } from '../../services/InvitationTokenService';
import { EnvelopeService } from '../../services/EnvelopeService';
import { SignerService } from '../../services/SignerService';
import { InvitationToken } from '../../domain/entities/InvitationToken';
import { Signature } from '../../domain/entities/Signature';
import { Envelope } from '../../domain/entities/Envelope';
import { SignatureId } from '../../domain/value-objects/SignatureId';
import { EnvelopeId } from '../../domain/value-objects/EnvelopeId';
import { SignerId } from '../../domain/value-objects/SignerId';
import { SignatureStatus } from '../../domain/enums/SignatureStatus';
import { calculateEnvelopeProgress } from '../../utils/envelope-progress';

/**
 * SignDocumentHandler - Production-ready handler using ControllerFactory
 * 
 * This handler processes document signing including consent validation,
 * signature creation, and status updates. It supports both authenticated
 * users (with JWT tokens) and external users (with invitation tokens).
 * 
 * @middleware
 * - JWT Authentication: Validates user identity and token validity (for authenticated users)
 * - Role validation: Ensures user has appropriate role permissions (for authenticated users)
 * - Request validation: Validates request body using SignDocumentRequestSchema
 * - Service orchestration: Coordinates between domain services
 * - Response formatting: Transforms domain entities to API response format
 * 
 * @flow
 * 1. Request Validation - Validates request body and determines user type
 * 2. User Authentication - Validates JWT token or invitation token
 * 3. Consent Validation - Validates consent for invitation token users
 * 4. Signature Creation - Creates signature using SignatureService
 * 5. Response Assembly - Returns complete signature information
 * 
 * @responsibilities
 * - Dual Authentication: Supports both JWT and invitation token authentication
 * - Signature Creation: Creates digital signatures using existing services
 * - Consent Validation: Validates consent for external users
 * - Business Validation: Validates business rules and constraints
 * - Response Formatting: Transforms domain entities to API response format
 * 
 * @exclusions
 * - Document Storage: Handled by S3Service (frontend uploads signed PDF)
 * - KMS Operations: Handled by SignatureService
 * - Audit Events: Generated by individual services
 * - Email Notifications: Handled by NotificationService
 */
export const signDocumentHandler = ControllerFactory.createCommand({
  // Validation schemas
  bodySchema: SignDocumentRequestSchema,
  
  // Parameter extraction
  extractParams: (_path: any, body: any, _query: any, context: any) => ({
    requestBody: body,
    securityContext: context.securityContext
  }),
  
  // Service configuration - use domain services directly
  appServiceClass: class {
    constructor() {
      // Create services from ServiceFactory
      this.signatureService = ServiceFactory.createSignatureService();
      this.invitationTokenService = ServiceFactory.createInvitationTokenService();
      this.envelopeService = ServiceFactory.createEnvelopeService();
      this.signerService = ServiceFactory.createSignerService();
    }
    
    private signatureService: SignatureService;
    private invitationTokenService: InvitationTokenService;
    private envelopeService: EnvelopeService;
    private signerService: SignerService;
    
    async execute(params: { requestBody: any; securityContext: any }) {
      const { requestBody, securityContext } = params;
      let envelopeId: string;
      let signerId: string;
      let invitationToken: InvitationToken | null = null;
      
      // Determine authentication method and extract envelope/signer info
      if (requestBody.invitationToken) {
        // External user with invitation token - validation handled by service
        invitationToken = await this.invitationTokenService.validateInvitationToken(requestBody.invitationToken);
        envelopeId = invitationToken.getEnvelopeId().getValue();
        signerId = invitationToken.getSignerId().getValue();
      } else {
        // Authenticated user with JWT token
        envelopeId = requestBody.envelopeId;
        signerId = requestBody.signerId;
      }
      // Create signature using real SignatureService
      const signatureId = new SignatureId(crypto.randomUUID());
      const signature: Signature = await this.signatureService.createSignature({
        id: signatureId,
        envelopeId: new EnvelopeId(envelopeId),
        signerId: new SignerId(signerId),
        documentHash: requestBody.documentHash,
        signatureHash: requestBody.signatureHash,
        s3Key: requestBody.s3Key,
        kmsKeyId: requestBody.kmsKeyId,
        algorithm: requestBody.algorithm,
        timestamp: new Date(),
        status: SignatureStatus.SIGNED,
        reason: requestBody.reason,
        location: requestBody.location,
        ipAddress: securityContext?.ipAddress,
        userAgent: securityContext?.userAgent
      });

      // Get real envelope status and progress
      const userId = invitationToken ? 'external-user' : 'authenticated-user';
      const mergedSecurityContext = { ...securityContext, userId };
      
      const envelope: Envelope = await this.envelopeService.getEnvelope(
        new EnvelopeId(envelopeId),
        userId,
        mergedSecurityContext
      );
      
      // Get signers to calculate real progress
      const signers = await this.signerService.getSignersByEnvelope(new EnvelopeId(envelopeId));
      const progress = calculateEnvelopeProgress(signers);
      
      // Return signing confirmation with real data
    return {
        message: 'Document signed successfully',
        signature: {
          id: signature.getId().getValue(),
          signerId: signature.getSignerId(),
          envelopeId: signature.getEnvelopeId(),
          signedAt: signature.getTimestamp().toISOString(),
          algorithm: signature.getAlgorithm(),
          hash: signature.getSignatureHash()
        },
        envelope: {
          id: envelopeId,
          status: envelope.getStatus(),
          progress: progress.percentage
        }
      };
    }
  },
  
  // Response configuration
  responseType: 'ok'
});