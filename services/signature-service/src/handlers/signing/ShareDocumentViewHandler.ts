/**
 * @fileoverview ShareDocumentViewHandler - Handler for sharing document view access
 * @summary Handles sharing document view access with external users (read-only)
 * @description This handler processes requests to share document view access with external users
 * who can only view (not sign) documents. It creates viewer participants, generates invitation tokens,
 * and publishes notification events for email delivery.
 */

import { ControllerFactory, VALID_COGNITO_ROLES } from '@lawprotect/shared-ts';
import { CompositionRoot } from '../../infrastructure/factories';
import { ShareDocumentViewPathSchema, ShareDocumentViewBodySchema } from '../../domain/schemas/ShareDocumentViewSchema';
import { EnvelopeId } from '../../domain/value-objects/EnvelopeId';

/**
 * ShareDocumentViewHandler - Production-ready handler using ControllerFactory
 *
 * @description This handler orchestrates document view sharing with external users who have
 * read-only access. It creates viewer participants, generates invitation tokens with custom
 * expiration, and publishes notification events for email delivery.
 *
 * @middleware
 * - JWT Authentication: Validates user identity and token validity
 * - Role validation: Ensures user has appropriate role permissions
 * - Request validation: Validates request body using ShareDocumentViewSchema
 * - Service orchestration: Coordinates between domain services using SignatureOrchestrator
 * - Response formatting: Transforms domain entities to API response format
 *
 * @flow
 * 1. Validation - Validates request body and business rules
 * 2. Viewer Creation - Creates viewer participant with participantRole: VIEWER
 * 3. Token Generation - Generates invitation token with custom expiration
 * 4. Notification Dispatch - Publishes events for notification service
 * 5. Response Assembly - Returns confirmation with token details
 *
 * @responsibilities
 * - Viewer Management: Creates viewer participants with read-only access
 * - Token Management: Generates invitation tokens for external viewers
 * - Notification Coordination: Publishes events for notification service
 * - Response Formatting: Transforms domain entities to API response format
 *
 * @exclusions
 * - Email Notifications: Handled by NotificationService via events
 * - Document Storage: Handled by Document Service
 * - Document Processing: Handled by Document Service
 * - Audit Events: Generated by individual services
 * - Permission Validation: Handled by middleware pipeline
 */
export const shareDocumentViewHandler = ControllerFactory.createCommand({
  // Validation schemas
  pathSchema: ShareDocumentViewPathSchema,
  bodySchema: ShareDocumentViewBodySchema,
  
  // Service configuration - use new DDD architecture
  /**
   * Lazy DI: construct orchestrator at first execution to avoid import-time DB access.
   */
  appServiceClass: class {
    private signatureOrchestrator: any | undefined;

    /**
     * Executes the document view sharing orchestration
     * 
     * @param params - Extracted parameters from request
     * @returns Promise resolving to share document view result
     */
    async execute(params: any) {
      const orchestrator = this.signatureOrchestrator ?? await CompositionRoot.createSignatureOrchestratorAsync();
      this.signatureOrchestrator = orchestrator;
      return await orchestrator.shareDocumentView(
        params.envelopeId,
        params.email,
        params.fullName,
        params.message,
        params.expiresIn,
        params.userId,
        params.securityContext
      );
    }
  },
  
  extractParams: (path: any, body: any, _query: any, context: any) => ({
    envelopeId: EnvelopeId.fromString(path.envelopeId),
    email: body.email,
    fullName: body.fullName,
    message: body.message,
    expiresIn: body.expiresIn,
    userId: context.auth.userId,
    securityContext: {
      ipAddress: context.auth.ipAddress,
      userAgent: context.auth.userAgent,
      country: context.auth.country
    }
  }),
  
  // Response configuration
  responseType: 'created',
  transformResult: async (result: any) => {
    return {
      success: result.success,
      message: result.message,
      envelopeId: result.envelopeId,
      viewerEmail: result.viewerEmail,
      viewerName: result.viewerName,
      token: result.token,
      expiresAt: result.expiresAt.toISOString(),
      expiresInDays: result.expiresInDays
    };
  },
  
  // Authentication and authorization
  requireAuth: true,
  requiredRoles: [...VALID_COGNITO_ROLES],
  includeSecurityContext: true
});