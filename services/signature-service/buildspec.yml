version: 0.2

phases:
  install:
    runtime-versions:
      nodejs: 20

  pre_build:
    commands:
      - |
        set -eu
        echo "[INFO] ===== Pre-build ====="
      - |
        echo "[INFO] Installing workspace dependencies (npm workspaces)"
        cd "$CODEBUILD_SRC_DIR"
        npm ci --workspaces --include-workspace-root --no-audit --no-fund
      - |
        echo "[INFO] Building packages/shared-ts"
        cd "$CODEBUILD_SRC_DIR/packages/shared-ts"
        export DATABASE_URL="${DATABASE_URL:-postgresql://user:pass@localhost:5432/postgres?schema=public}"
        npm run prisma:generate
        npm run build
      - |
        echo "[INFO] Using workspace install; skipping per-service npm ci"
      - |
        echo "[INFO] Preparing Prisma client"
        cd "$CODEBUILD_SRC_DIR/services/signature-service"
        if [ -d "$CODEBUILD_SRC_DIR/packages/shared-ts/prisma" ]; then
          mkdir -p prisma
          cp -r "$CODEBUILD_SRC_DIR/packages/shared-ts/prisma/"* prisma/
        fi
        export DATABASE_URL="${DATABASE_URL:-postgresql://user:pass@localhost:5432/postgres?schema=public}"
        npx -y prisma@5.22.0 generate
        node -e "try{require.resolve('@prisma/client');console.log('[OK] @prisma/client')}catch(e){console.error(e);process.exit(1)}"
        node -e "try{require.resolve('@lawprotect/shared-ts');console.log('[OK] @lawprotect/shared-ts')}catch(e){console.error(e);process.exit(1)}"

  build:
    commands:
      - |
        set -eu
        echo "[INFO] ===== Build & Package ====="
      - |
        echo "[INFO] Running unit tests"
        cd "$CODEBUILD_SRC_DIR/services/signature-service"
        export DATABASE_URL="${DATABASE_URL:-postgresql://user:pass@localhost:5432/postgres?schema=public}"
        npm run test:unit:coverage
      - |
        echo "[INFO] Building service (ESM)"
        cd "$CODEBUILD_SRC_DIR/services/signature-service"
        npm run build

      # ===== Deps layer skipped (using bundled core) =====
      - |
        echo "[INFO] Skipping dependencies layer; core layer will include runtime deps via bundling"

      # ===== Shared-TS layer (SKIPPED here; managed por pipeline/layer propio) =====
      - |
        echo "[INFO] Skipping shared-ts layer build/publish in this pipeline (managed separately)"

      # ===== Prisma layer (SKIPPED; Prisma vive en shared-ts layer) =====
      - |
        echo "[INFO] Skipping prisma layer; @prisma/client y engines van en shared-ts layer"

      # ===== Core layer (ESM) =====
      - |
        echo "[INFO] Building core layer (ESM)"
        cd "$CODEBUILD_SRC_DIR/services/signature-service"
        rm -rf layer-core sign-core-layer.zip

        mkdir -p "layer-core/nodejs/node_modules/@lawprotect/sign-core"


        # Create ESM bundle entry that re-exports handlers
        cat > "core-bundle-entry.mjs" << 'EOF'
        import { createEnvelopeHandler } from './dist/src/handlers/envelopes/CreateEnvelopeHandler.js';
        import { getEnvelopeHandler } from './dist/src/handlers/envelopes/GetEnvelopeHandler.js';
        import { sendEnvelopeHandler } from './dist/src/handlers/envelopes/SendEnvelopeHandler.js';
        import { updateEnvelopeHandler } from './dist/src/handlers/envelopes/UpdateEnvelopeHandler.js';
        import { cancelEnvelopeHandler } from './dist/src/handlers/envelopes/CancelEnvelopeHandler.js';
        import { getEnvelopesByUserHandler } from './dist/src/handlers/envelopes/GetEnvelopesByUserHandler.js';
        import { downloadDocumentHandler } from './dist/src/handlers/envelopes/DownloadDocumentHandler.js';
        import { signDocumentHandler } from './dist/src/handlers/signing/SignDocumentHandler.js';
        import { declineSignerHandler } from './dist/src/handlers/signing/DeclineSignerHandler.js';
        import { shareDocumentViewHandler } from './dist/src/handlers/signing/ShareDocumentViewHandler.js';
        import { sendNotificationHandler } from './dist/src/handlers/notifications/SendNotificationHandler.js';
        import { getAuditTrailHandler } from './dist/src/handlers/audit/GetAuditTrailHandler.js';
        export const handlers = {
          createEnvelope: createEnvelopeHandler,
          getEnvelope: getEnvelopeHandler,
          sendEnvelope: sendEnvelopeHandler,
          updateEnvelope: updateEnvelopeHandler,
          cancelEnvelope: cancelEnvelopeHandler,
          getEnvelopesByUser: getEnvelopesByUserHandler,
          downloadDocument: downloadDocumentHandler,
          signDocument: signDocumentHandler,
          declineSigner: declineSignerHandler,
          shareDocument: shareDocumentViewHandler,
          sendNotification: sendNotificationHandler,
          getAuditTrail: getAuditTrailHandler
        };
        EOF

        # Bundle with esbuild (Node 20 CJS), external only Prisma (native)
        npx -y esbuild@0.21.5 core-bundle-entry.mjs \
          --bundle --platform=node --format=cjs --target=node20 \
          --external:@prisma/client \
          --minify --sourcemap \
          --outfile="layer-core/nodejs/node_modules/@lawprotect/sign-core/index.js"
        
        # Inject crypto polyfill manually at the start of the bundle (CJS)
        echo "const{webcrypto:__wc}=require('node:crypto');if(!globalThis.crypto)globalThis.crypto=__wc;" > __banner.js
        cat layer-core/nodejs/node_modules/@lawprotect/sign-core/index.js >> __banner.js
        mv __banner.js layer-core/nodejs/node_modules/@lawprotect/sign-core/index.js

        # package.json del módulo (CommonJS)
        cat > "layer-core/nodejs/node_modules/@lawprotect/sign-core/package.json" << 'EOF'
        {
          "name": "@lawprotect/sign-core",
          "version": "1.0.0",
          "main": "index.js",
          "type": "commonjs"
        }
        EOF


        (cd layer-core && zip -qr ../sign-core-layer.zip .)
        test -s sign-core-layer.zip || { echo "[ERROR] sign-core-layer.zip is empty"; exit 1; }
        # Validate bundled index exists
        unzip -l sign-core-layer.zip | grep -q 'nodejs/node_modules/@lawprotect/sign-core/index\.js' \
          || { echo "[ERROR] index.js bundle missing from core layer"; exit 1; }
        rm -rf layer-core
        echo "[INFO] Core layer ZIP created"

      # ===== Zips de funciones (ESM) =====
      - |
        echo "[INFO] Creating minimal CJS function ZIPs"
        cd "$CODEBUILD_SRC_DIR/services/signature-service"

        make_zip() {
          local zip="$1"
          local exp="$2"
          rm -rf __tmp_fn
          mkdir -p __tmp_fn
          cat > __tmp_fn/index.js << EOF
        const { webcrypto } = require('node:crypto');
        if (!globalThis.crypto) { globalThis.crypto = webcrypto; }
        const { handlers } = require('@lawprotect/sign-core');
        exports.handler = handlers.${exp};
        EOF
          cat > __tmp_fn/package.json << 'EOF'
        { "type": "commonjs" }
        EOF
          (cd __tmp_fn && zip -qr "../$zip" .)
          rm -rf __tmp_fn
        }

        make_zip "sign-create-envelope.zip"        "createEnvelope"
        make_zip "sign-get-envelope.zip"           "getEnvelope"
        make_zip "sign-send-envelope.zip"          "sendEnvelope"
        make_zip "sign-sign-document.zip"          "signDocument"
        make_zip "sign-decline-signer.zip"         "declineSigner"
        make_zip "sign-share-document.zip"         "shareDocument"
        make_zip "sign-send-notification.zip"      "sendNotification"
        make_zip "sign-get-audit-trail.zip"        "getAuditTrail"
        make_zip "sign-get-envelopes-by-user.zip"  "getEnvelopesByUser"
        make_zip "sign-update-envelope.zip"        "updateEnvelope"
        make_zip "sign-cancel-envelope.zip"        "cancelEnvelope"
        make_zip "sign-download-document.zip"      "downloadDocument"

      # ===== Publicar layers (con fallback a última versión) =====
      - |
        echo "[INFO] Uploading layers to S3 & publishing versions"
        set -euo
        cd "$CODEBUILD_SRC_DIR/services/signature-service"

        if [ -z "${CODE_BUCKET:-}" ]; then
          echo "[ERROR] CODE_BUCKET not set"
          exit 1
        fi

        AWS_ACCOUNT_ID="${AWS_ACCOUNT_ID:-$(aws sts get-caller-identity --query Account --output text)}"
        AWS_REGION="${AWS_REGION:-${AWS_DEFAULT_REGION:-us-east-1}}"

        aws s3 cp "sign-core-layer.zip"   "s3://$CODE_BUCKET/sign-core-layer.zip"

        # Quick sanity check that S3 object exists
        aws s3 ls "s3://$CODE_BUCKET/sign-core-layer.zip"   >/dev/null

        publish_layer() {
          NAME="$1"
          ZIP="$2"
          DESC="$3"
          # Enforce 50MB compressed limit for Lambda layers
          ZIP_SIZE=$( (stat -c%s "$ZIP" 2>/dev/null) || (wc -c < "$ZIP") )
          MAX_SIZE=$((50*1024*1024))
          if [ "$ZIP_SIZE" -gt "$MAX_SIZE" ]; then
            echo "[ERROR] $ZIP exceeds 50MB compressed limit ($ZIP_SIZE bytes)" >&2
            exit 1
          fi
          # Publish and capture errors for diagnostics
          if ! ARN=$(aws lambda publish-layer-version \
            --region "$AWS_REGION" \
            --layer-name "$NAME" \
            --description "$DESC" \
            --content S3Bucket="$CODE_BUCKET",S3Key="$ZIP" \
            --compatible-runtimes nodejs20.x \
            --query LayerVersionArn --output text 2>"publish-$NAME.err"); then
            echo "[ERROR] Failed to publish layer $NAME (see below)" >&2
            cat "publish-$NAME.err" >&2 || true
            exit 1
          fi
          if [ -z "$ARN" ] || [ "$ARN" = "None" ]; then
            echo "[ERROR] Failed to obtain ARN for layer $NAME" >&2
            cat "publish-$NAME.err" >&2 || true
            exit 1
          fi
          echo "$ARN"
        }

        CORE_LAYER_NAME="${SIGNATURE_LAYER_NAME:-lawprotect365-sign-core-stg}"
        SHARED_LAYER_NAME="${SHARED_TS_LAYER_NAME:-${PROJECT_NAME:-lawprotect365}-shared-ts-layer-${ENV:-stg}}"

        CORE_LAYER_VERSION="$(publish_layer "$CORE_LAYER_NAME" "sign-core-layer.zip" "Signature service core code")"

        echo "[INFO] Core layer ARN:   ${CORE_LAYER_VERSION:-<empty>}"

        aws lambda list-layer-versions --region "$AWS_REGION" --layer-name "$CORE_LAYER_NAME" --max-items 5 || true

      # ===== Deploy de funciones =====
      - |
        echo "[INFO] Deploying Lambda functions (no alias shift; CodeDeploy will move aliases)"
        cd "$CODEBUILD_SRC_DIR/services/signature-service"

        AWS_ACCOUNT_ID="${AWS_ACCOUNT_ID:-$(aws sts get-caller-identity --query Account --output text)}"
        # Resolve shared layer to latest version if ARN not versioned
        if [ -n "${SHARED_TS_LAYER_ARN:-}" ] && echo "$SHARED_TS_LAYER_ARN" | grep -q ':'; then
          SHARED_LAYER_ARN="$SHARED_TS_LAYER_ARN"
        else
          SHARED_LAYER_NAME="${SHARED_TS_LAYER_NAME:-${PROJECT_NAME:-lawprotect365}-shared-ts-layer-${ENV:-stg}}"
          SHARED_LAYER_ARN="$(aws lambda list-layer-versions \
            --layer-name "$SHARED_LAYER_NAME" \
            --query "sort_by(LayerVersions, &Version)[-1].LayerVersionArn" \
            --output text 2>/dev/null || true)"
        fi

        build_layers_args() {
          args=""
          if [ -n "${SHARED_LAYER_ARN:-}" ] && [ "${SHARED_LAYER_ARN}" != "None" ]; then
            args="${args} ${SHARED_LAYER_ARN}"
          fi
          if [ -n "${CORE_LAYER_VERSION:-}" ] && [ "${CORE_LAYER_VERSION}" != "None" ]; then
            args="${args} ${CORE_LAYER_VERSION}"
          fi
          echo "$args" | sed -e 's/^ *//'
        }

        # Build manifest JSON to iterate
        python3 - "$FUNCTIONS_MANIFEST" > /tmp/functions.json << 'PY'
        import json,sys
        raw = sys.argv[1] if len(sys.argv)>1 else "[]"
        try:
          data = json.loads(raw)
          assert isinstance(data, list)
        except Exception:
          data = []
        print(json.dumps(data))
        PY
        jq -e . >/dev/null 2>&1 || { echo "[ERROR] jq is required"; exit 1; }
        FUNS="$(cat /tmp/functions.json)"
        LAYERS_ARGS="$(build_layers_args)"
        : > /tmp/versions.jsonl
        for row in $(echo "$FUNS" | jq -c '.[]'); do
          FN=$(echo "$row" | jq -r '.functionName')
          ZIP=$(echo "$row" | jq -r '.artifactS3Key')
          ALIAS=$(echo "$row" | jq -r '.alias')
          echo "[INFO] Deploying $FN (artifact=$ZIP, alias=$ALIAS)"
          aws s3 cp "$ZIP" "s3://$CODE_BUCKET/$ZIP"
          aws lambda update-function-code --function-name "$FN" --s3-bucket "$CODE_BUCKET" --s3-key "$ZIP" >/dev/null
          aws lambda wait function-updated --function-name "$FN"
          ENV_JSON="$(aws lambda get-function-configuration --function-name "$FN" --query 'Environment.Variables' --output json 2>/dev/null || echo '{}')"
          ENV_ARG="$(python3 -c "import json,sys; raw=sys.argv[1] if len(sys.argv)>1 else '{}'; env=json.loads(raw or '{}') or {}; env['NODE_OPTIONS']='--experimental-specifier-resolution=node'; print(json.dumps({'Variables': env}, separators=(',',':')))" "$ENV_JSON")"
          if [ -n "$LAYERS_ARGS" ]; then
            aws lambda update-function-configuration --function-name "$FN" --runtime nodejs20.x --handler index.handler --layers $LAYERS_ARGS --environment "$ENV_ARG" >/dev/null
          else
            aws lambda update-function-configuration --function-name "$FN" --runtime nodejs20.x --handler index.handler --environment "$ENV_ARG" >/dev/null
          fi
          aws lambda wait function-updated --function-name "$FN"
          CURRENT_BEFORE="$(aws lambda get-alias --function-name "$FN" --name "$ALIAS" --query FunctionVersion --output text 2>/dev/null || true)"
          TARGET_VERSION="$(aws lambda publish-version --function-name "$FN" --description "Build-$(date +%s)" --query Version --output text 2>/dev/null || true)"
          if [ -z "$TARGET_VERSION" ] || [ "$TARGET_VERSION" = "None" ] || [ "$TARGET_VERSION" = "null" ]; then
            TARGET_VERSION="$(aws lambda publish-version --function-name "$FN" --query Version --output text 2>/dev/null || true)"
          fi
          [ -z "$CURRENT_BEFORE" ] || [ "$CURRENT_BEFORE" = "None" ] && CURRENT_BEFORE="$TARGET_VERSION"
          echo "{\"name\":\"$FN\",\"alias\":\"$ALIAS\",\"current\":\"$CURRENT_BEFORE\",\"target\":\"$TARGET_VERSION\"}" >> /tmp/versions.jsonl

          # Sanity invoke the published version to surface runtime errors without failing the build
          ERR=$(aws lambda invoke --function-name "$FN" --qualifier "$TARGET_VERSION" --payload '{}' /tmp/invoke.json --query FunctionError --output text 2>/dev/null || true)
          if [ -n "$ERR" ] && [ "$ERR" != "None" ]; then
            echo "[WARN] Sanity invoke failed for $FN (v$TARGET_VERSION) FunctionError=$ERR"
            cat /tmp/invoke.json || true
          else
            echo "[INFO] Sanity invoke OK for $FN (v$TARGET_VERSION)"
          fi
        done

      - |
        echo "[INFO] Writing appspec.yml from published versions"
        cd "$CODEBUILD_SRC_DIR/services/signature-service"
        {
          echo "version: 0.0"
          echo "Resources:"
          while read -r line; do
            NAME="$(echo "$line" | jq -r '.name')"
            ALIAS="$(echo "$line" | jq -r '.alias')"
            CURR="$(echo "$line" | jq -r '.current')"
            TGT="$(echo "$line" | jq -r '.target')"
            echo "  - $(basename "$NAME"):"
            echo "      Type: AWS::Lambda::Function"
            echo "      Properties:"
            echo "        Name: \"$NAME\""
            echo "        Alias: \"$ALIAS\""
            echo "        CurrentVersion: $CURR"
            echo "        TargetVersion: $TGT"
          done < /tmp/versions.jsonl
        } > appspec.yml

artifacts:
  files:
    - "services/signature-service/appspec.yml"
  discard-paths: yes
